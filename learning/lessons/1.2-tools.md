# Lesson 1.2: File Operations Tooling

**Task:** Create `blogger/tools.py` for file reading/writing/splitting

**Completed:** Phase 1

---

## üß† Key Concepts Learned

### Project Root Navigation
Use `Path(__file__).parent.parent` to navigate from a module to the project root.

**Example:**
```python
from pathlib import Path

# In blogger/tools.py
CURRENT_DIR = Path(__file__).parent  # ‚Üí .../blogger/
PROJECT_ROOT = CURRENT_DIR.parent     # ‚Üí .../ai-blog-partner/

INPUTS_DIR = PROJECT_ROOT / "inputs"
OUTPUTS_DIR = PROJECT_ROOT / "outputs"
```

**Why:** Ensures correct paths for project-wide directories regardless of where code is imported from.

---

### Path Constants
Define directory paths as **module-level constants** for reusability.

**Pattern:**
```python
# At top of tools.py
INPUTS_DIR = CURRENT_DIR.parent / "inputs"
OUTPUTS_DIR = CURRENT_DIR.parent / "outputs"

# Use throughout the module
def read_draft_tool(blog_id: str) -> dict:
    draft_path = INPUTS_DIR / blog_id / "draft.md"
    ...
```

**Benefits:**
- Single source of truth
- Easy to change directory structure
- Clear and readable code

---

### Path Composition
Use the `/` operator with `Path` objects for clean path construction.

**Example:**
```python
# ‚úÖ Clean and readable
draft_path = INPUTS_DIR / blog_id / "draft.md"

# ‚ùå String concatenation (error-prone)
draft_path = Path(str(INPUTS_DIR) + "/" + blog_id + "/draft.md")
```

**Why:** The `/` operator handles path separators correctly across OS (Windows vs Unix).

---

### Safe Directory Creation
Use `Path.mkdir(parents=True, exist_ok=True)` for safe nested directory creation.

**Pattern:**
```python
output_dir = OUTPUTS_DIR / blog_id
output_dir.mkdir(parents=True, exist_ok=True)
```

**Parameters:**
- `parents=True` - Creates intermediate directories (like `mkdir -p`)
- `exist_ok=True` - Doesn't raise error if directory already exists

---

### Minimal Error Handling
Check for file existence before reading and raise **clear, descriptive exceptions**.

**Pattern:**
```python
if not draft_path.exists():
    raise FileNotFoundError(
        f"Draft not found for blog '{blog_id}'. "
        f"Expected at: {draft_path}"
    )
```

**Why:**
- Fails fast with clear error messages
- Helps debugging by pointing to exact issue
- Better than cryptic OS-level errors

---

## üìù Files Created

- `blogger/tools.py` - File operation tools (read_draft_tool, save_step_tool)

---

## üéØ Takeaway

Use `pathlib.Path` for all file operations. It's more robust, cross-platform compatible, and readable than string manipulation. Always use project-relative paths, never absolute or working-directory-relative paths.
