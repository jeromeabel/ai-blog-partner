# Lesson 2.1: LoopAgent Pattern & Functional Architecture

**Task:** Implement Step 1 (Draft to Outlines) with quality control

**Completed:** Phase 2 (Tasks 2.1.1, 2.1.2, 2.1.3)

---

## üß† Part 1: LoopAgent Pattern & Validation

### BaseAgent Pattern
Custom agents extend `BaseAgent` and implement the async generator method:

```python
from google.adk.agents import BaseAgent
from google.adk.agents.invocation_context import InvocationContext
from typing import AsyncGenerator

class OutlineValidationChecker(BaseAgent):
    async def _run_async_impl(
        self, ctx: InvocationContext
    ) -> AsyncGenerator[Event, None]:
        # Validation logic here
        yield Event(...)
```

**Foundation:** All custom agent logic in ADK.

---

### Loop Termination Signal
Use `yield Event(author=self.name, actions=EventActions(escalate=True))` to signal LoopAgent to **exit successfully**.

**Pattern:**
```python
if is_valid:
    yield Event(
        author=self.name,
        content=types.Content(parts=[
            types.Part(text="Validation passed")
        ]),
        actions=EventActions(escalate=True)  # ‚Üê EXIT SIGNAL
    )
```

**Meaning:** "Quality check passed, stop looping."

---

### Continue Loop Signal
Use `yield Event(author=self.name, content=...)` **without escalate** to signal LoopAgent to **retry**.

**Pattern:**
```python
if not is_valid:
    yield Event(
        author=self.name,
        content=types.Content(parts=[
            types.Part(text="Validation failed: need 3+ sections")
        ])
        # No escalate ‚Üí signals: CONTINUE LOOP
    )
```

---

### Session State Access
Read from session state with `ctx.session.state.get("key", default)`.

**Example:**
```python
async def _run_async_impl(self, ctx):
    outline = ctx.session.state.get("blog_outline", "")
    draft = ctx.session.state.get("raw_draft", "")
```

**Purpose:** How agents share data within a single conversation session (short-term memory).

---

### Event Structure
Events must have:
- `author=self.name` (required)
- `content` (optional) - types.Content with types.Part for messages
- `actions` (optional) - EventActions for control signals like escalate

---

### EventActions Usage
`EventActions(escalate=True)` goes **INSIDE** the Event, not as a direct parameter.

**Common mistake:**
```python
# ‚ùå Wrong
Event(escalate=True)

# ‚úÖ Correct
Event(actions=EventActions(escalate=True))
```

---

### Validation Best Practices
- Check existence before accessing data (avoid KeyError)
- Provide specific, actionable error messages for debugging
- Handle edge cases (empty data, type mismatches, zero-length inputs)
- Validate quality criteria (structure, completeness), not just existence
- Use defensive programming (isinstance checks, default values)

---

### LoopAgent Quality Control (The "Polisher" Pattern)
Wrap a worker agent + validator for automatic quality retries.

**Flow:**
```
Worker creates output ‚Üí Validator checks quality
    ‚Üì                          ‚Üì
  Writes to                 Reads from
session state             session state
    ‚Üì                          ‚Üì
If valid: escalate=True ‚Üí EXIT LOOP ‚úÖ
If invalid: no escalate ‚Üí RETRY (back to worker) üîÑ
```

**Example:**
```python
robust_outline_step = LoopAgent(
    name="robust_outline_step",
    sub_agents=[
        outline_creator,           # Worker
        OutlineValidationChecker   # Validator
    ],
    max_iterations=3
)
```

---

## üß† Part 2: Testing & Refactoring

### Extract Pure Functions for Testability
Move validation logic from class methods to **module-level pure functions**.

**Why:** Enables easy unit testing without mocking ADK runtime.

**Pattern:**
```python
# validation_utils.py (pure functions)
def check_outline_structure(outline_text: str) -> tuple[bool, list[str]]:
    """Pure function - easy to test."""
    sections = [line for line in outline_text.split("\n") if line.startswith("## ")]
    is_valid = len(sections) >= 3
    return is_valid, []

# validation_checkers.py (ADK integration)
class OutlineValidationChecker(BaseAgent):
    async def _run_async_impl(self, ctx):
        outline = ctx.session.state.get("blog_outline", "")
        is_valid, reasons = check_outline_structure(outline)  # ‚Üê Use pure function
        # Yield appropriate Event based on result
```

---

### Separation of Concerns
- **Business logic** (validation rules) ‚Üí Pure functions
- **Framework integration** (ADK agents) ‚Üí BaseAgent classes

Functions do the logic, agents handle Events/state.

---

### Utils Module Pattern
Create `validation_utils.py` for reusable validation functions.

**Benefits:**
- Easy to test (no mocking needed)
- Reusable across validators
- No async complexity for logic
- Clear input/output contracts

---

### Comprehensive Unit Testing
Write tests for edge cases:
- Empty input
- Whitespace
- Case sensitivity
- Duplicates
- Missing data

**Aim for 100% code coverage.**

---

### Pytest Basics
```python
import pytest
from blogger.validation_utils import check_outline_structure

class TestOutlineStructure:
    def test_valid_outline(self):
        outline = "## Intro\n## Body\n## Conclusion"
        is_valid, reasons = check_outline_structure(outline)
        assert is_valid

    def test_too_few_sections(self):
        outline = "## Intro\n## Conclusion"
        is_valid, reasons = check_outline_structure(outline)
        assert not is_valid
```

**Commands:**
```bash
pytest tests/ -v                                    # Run tests
pytest tests/ --cov=blogger --cov-report=term-missing  # With coverage
```

---

## üß† Part 3: Agent Instructions & Multi-Agent Delegation

### Agent Instruction Structure (Official Pattern)
Follow ADK-recommended hierarchy:
1. **Role definition** ("You are...")
2. **Primary task** ("Your task is...")
3. **Tool guidance** (when/why to use each tool)
4. **Constraints** (scope limitations)
5. **Output format** (explicit specification)

---

### Tool Reference Pattern
Never just list tools. Explain **WHEN and WHY** to use each tool.

**Example:**
```markdown
# ‚úÖ Good
Use `read_draft_tool` to load the raw draft content from disk.

# ‚ùå Bad
You have tools: read_draft_tool
```

**Why:** Tool docstrings are the primary source of truth for the LLM.

---

### Sub-Agent Delegation Pattern
In coordinator instructions, explicitly state delegation triggers.

**Examples:**
- "Collaborate with Scribr to analyze..."
- "Use the `robust_blog_planner` tool to..." (ADK treats sub-agents as invokable tools)

Include clear `description` fields on sub-agents to guide routing decisions.

---

### Output Format Specification
Show the **EXACT expected format** with examples (few-shot learning).

**Pattern:**
```markdown
Output a dictionary with two keys:
- "draft_ok": String containing content that aligns with the outline
- "draft_not_ok": String containing unused content

Example output format:
{
    "draft_ok": "Content that matches...",
    "draft_not_ok": "Remaining content..."
}
```

**Why:** Reduces hallucination and ensures consistency.

---

### Worker vs Coordinator Instructions

| Aspect | Worker Agent | Coordinator Agent |
|--------|--------------|-------------------|
| **Scope** | Narrow ("Your ONLY task is...") | Broad (orchestration) |
| **Focus** | Direct execution | Routing/delegation |
| **Tools** | Domain-specific | Minimal (coordination) |
| **Sub-agents** | Usually none or 1-2 specialists | Multiple workers |

---

### Variable Naming Convention
Agent variable names **must match** the `name=""` parameter exactly.

**Example:**
```python
outline_creator = Agent(name="outline_creator", ...)  # ‚Üê Names match
```

**Why:** Consistency in logs, debugging, and imports.

---

### Agent Hierarchy is Dynamic
There's no fixed "main agent." Hierarchy is **call-stack based**:
- When `outline_creator` runs, IT is the boss and Scribr is its worker
- When `orchestrator` runs, IT is the boss and `outline_creator` is its worker

**Think:** Like nested function calls.

---

### max_iterations Behavior
When LoopAgent reaches max_iterations without `escalate=True`:
- Stops gracefully (no error)
- Preserves the last output in session state
- Returns control to parent

**Purpose:** Safety net to prevent infinite loops while forcing forward progress.

---

### Explicit Constraints Prevent Scope Creep
Use "ONLY" language and negative constraints ("Do not engage in...") to keep agents focused.

**Why:** Vague language like "if appropriate" leads to unpredictable behavior.

---

## üß† Part 4: Session State Strategy & Functional Architecture

### output_key vs save_step_tool Strategy
Two different memory systems:

| Concept | `output_key` | `save_step_tool` |
|---------|--------------|------------------|
| **What** | Session state | File persistence |
| **Purpose** | Agent-to-agent communication | User deliverables |
| **Lifetime** | Current session only | Permanent |
| **Automatic?** | Yes (ADK framework) | No (manual call) |

**Pattern:** Use BOTH
1. Agents write to session state via `output_key`
2. Orchestrator persists selected results to disk via `save_step_tool`

---

### Session State Persistence
Session state persists **throughout the entire session** across multiple agent invocations.

**Example:**
```
robust_outline_step runs:
  ‚Üí draft_loader writes state['raw_draft']
  ‚Üí outline_creator reads state['raw_draft']
  ‚Üí outline_creator writes state['blog_outline']

robust_content_split_step runs:
  ‚Üí content_splitter reads state['raw_draft']  ‚Üê Still there!
  ‚Üí content_splitter reads state['blog_outline'] ‚Üê Still there!
```

---

### Load Once, Share via State
Load external data (files, APIs) **ONCE** at workflow boundaries, store in session state, then all downstream agents read from state.

**Benefits:**
- Avoids redundant I/O
- Ensures consistency (all agents see identical data)
- Faster execution

---

### Setup Agent Pattern
Create dedicated "loader" agents with single responsibility: load external data ‚Üí store via `output_key`.

**Example:**
```python
draft_loader = Agent(
    name="draft_loader",
    description="Loads raw draft into session state",
    instruction="Use read_draft_tool to load the raw draft content.",
    tools=[FunctionTool(read_draft_tool)],
    output_key="raw_draft",  # ‚Üê Automatic storage!
)
```

**Use fast models** (e.g., `gemini-2.5-flash`) for simple I/O tasks.

---

### Functional Core, Imperative Shell
Architectural pattern separating side effects (I/O) from pure logic.

**Imperative Shell (Orchestrator):**
- Handles I/O boundaries
- File reads, file writes, API calls, external state
- Example: `draft_loader`, `save_step_tool`

**Functional Core (Worker Agents):**
- Pure processors with **NO I/O**
- Read from session state, process data, write to session state
- Example: `outline_creator`, `content_splitter`

**Benefits:**
- **Testability:** Pure functions don't need I/O mocking
- **Reliability:** Same input = same output
- **Composability:** Workers reusable across workflows

---

### I/O Boundaries in Multi-Agent Systems
Handle external I/O at the **outermost workflow boundary** (orchestrator level), then pass data via session state to inner agents.

**Pattern:**
```
Orchestrator (I/O boundary):
  ‚Üì
  Load external data (file) ‚Üí session state
  ‚Üì
  Call worker agents (they read from session state)
  ‚Üì
  Save outputs (from session state to files)
```

---

### Pure Processor Agents
Worker agents that have **NO tools** (no I/O capability), only read/write session state.

**Example:**
```python
outline_creator = Agent(
    name="outline_creator",
    instruction="Read raw_draft from session state...",
    tools=[],  # ‚Üê No I/O!
    output_key="blog_outline"
)
```

**Benefit:** Keeps workers focused on logic, not I/O concerns.

---

### Data Flow Clarity
Explicit I/O in orchestrator instructions makes data flow visible.

**Example:**
```markdown
Step 1:
- Use draft_loader to load (I/O)
- Use robust_outline_step to process (logic)
- Use save_step_tool to persist (I/O)
```

**Reader can understand** sequence without diving into agent internals.

---

### Session State as the Notebook
Think of session state as a **shared notebook** where agents write notes for each other.

Each agent:
- Contributes knowledge (via `output_key`)
- Reads others' notes (via `ctx.session.state.get()`)
- Builds up context progressively through workflow

---

## üìù Files Created

- `blogger/validation_checkers.py` - BaseAgent validators
- `blogger/validation_utils.py` - Pure validation functions
- `blogger/step_agents/__init__.py` - Package marker
- `blogger/step_agents/step_1_outline.py` - Worker agents and LoopAgents
- `blogger/workflow.py` - Updated orchestrator (integration)
- `tests/test_validation_utils.py` - Unit tests with 100% coverage

---

## üéØ Takeaways

1. **LoopAgent = Quality Control:** Automatic retry pattern for reliable outputs
2. **Pure Functions = Testability:** Extract logic from framework integration
3. **Session State = Agent Memory:** Load once, share across agents
4. **Functional Architecture:** I/O at boundaries, pure logic in workers
5. **Explicit Instructions:** Show format, explain tools, constrain scope

---

## üìñ Official Resources

- [Loop Agents](https://google.github.io/adk-docs/agents/workflow-agents/loop-agents/)
- [Custom Agents](https://google.github.io/adk-docs/agents/custom-agents/)
- [Events & EventActions](https://google.github.io/adk-docs/events/)
- [Agent Team Tutorial](https://google.github.io/adk-docs/tutorials/agent-team/)
