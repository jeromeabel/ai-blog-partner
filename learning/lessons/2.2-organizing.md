# Lesson 2.2: Multi-Agent Architecture & Instruction Design

**Task:** Implement Step 2 (Organization) - Reorganize draft content to match outline structure

**Completed:** Phase 2, Task 2.2 (Step 2 Organizing)

---

## ğŸ§  Part 1: Three-Layer Architecture

### The Orchestrator-Worker-Validator Pattern

Multi-agent systems in ADK follow a clear hierarchical pattern:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 1: ORCHESTRATOR                      â”‚
â”‚ - Coordinates workflow steps                â”‚
â”‚ - Handles I/O boundaries (files â†” state)   â”‚
â”‚ - Delegates to sub-agents                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 2: WORKER AGENTS                     â”‚
â”‚ - Pure processors (NO file I/O)            â”‚
â”‚ - Read from session state                  â”‚
â”‚ - Process/transform data                   â”‚
â”‚ - Write to session state via output_key   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 3: VALIDATION AGENTS                 â”‚
â”‚ - Quality control checks                   â”‚
â”‚ - Read from session state                  â”‚
â”‚ - Signal loop: continue or exit            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Principle:** Separation of concerns - orchestrator handles I/O, workers handle logic, validators ensure quality.

---

### Functional Core, Imperative Shell

This architectural pattern separates side effects from pure logic:

**Imperative Shell (Orchestrator):**
- Handles external boundaries: file reads, file writes, API calls
- Examples: `draft_loader`, `save_step_tool`
- Manages the "real world" interactions

**Functional Core (Workers):**
- Pure data processing with NO I/O
- Read from session state â†’ process â†’ write to session state
- Examples: `organizer`, `outline_creator`, `content_splitter`

**Benefits:**
- **Testability:** Pure functions easier to test (no mocking needed)
- **Reliability:** Same input always produces same output
- **Composability:** Workers reusable across different workflows
- **Clarity:** Clear data flow, obvious I/O boundaries

---

### Session State vs File I/O

Two separate memory systems with different purposes:

| Aspect | Session State | File I/O |
|--------|--------------|----------|
| **What** | In-memory dictionary | Disk storage |
| **Lifetime** | Current session only | Permanent |
| **Purpose** | Agent communication | User deliverables |
| **Speed** | Fast (RAM) | Slower (disk) |
| **Who uses** | All agents | Orchestrator only |
| **How set** | `output_key` or manual | `save_step_tool` |
| **How read** | `ctx.session.state.get()` | `read_draft_tool` |

**Pattern:**
```
FILE â†’ SESSION STATE â†’ PROCESS â†’ SESSION STATE â†’ FILE
(load)    (share)      (agents)    (result)      (save)
```

---

## ğŸ§  Part 2: Session State as Shared Memory

### Session State Persistence

Session state persists **throughout the entire workflow** across multiple agent invocations:

```
Step 1:
  draft_loader sets: state['raw_draft']
  outline_creator sets: state['blog_outline']
  content_splitter sets: state['content_split']

Step 2:
  organizer reads: state['blog_outline']  â† Still there!
  organizer reads: state['content_split'] â† Still there!
  organizer sets: state['draft_organized']

Step 3:
  writer reads: state['draft_organized'] â† Available!
```

**Key Insight:** Once data is in session state, ALL subsequent agents can access it.

---

### Load Once, Share Everywhere

Best practice: Load external data ONCE at workflow boundaries, then share via session state.

**Example - Step 2 Data Flow:**
```
ORCHESTRATOR workflow.py instructions:
  "Use robust_organizer_step to reorganize content"
                â†“
WORKER organizer reads from session state:
  - blog_outline (set by Step 1)
  - content_split.draft_ok (set by Step 1)
                â†“
WORKER organizer processes:
  - Match content to outline sections
  - Reorganize to match outline order
                â†“
WORKER organizer writes via output_key:
  - draft_organized â†’ session state
                â†“
VALIDATOR ReorganizationValidationChecker:
  - Reads: draft_organized, blog_outline, content_split.draft_ok
  - Checks: All content preserved? Structure matches?
  - Signals: escalate=True (exit) or continue (retry)
                â†“
ORCHESTRATOR saves to disk:
  - save_step_tool(blog_id, "draft_organized", ...)
  - File created: outputs/<blog_id>/draft_organized.md
```

**Benefits:**
- Avoids redundant file reads
- Ensures data consistency (all agents see same data)
- Faster execution (no repeated I/O)

---

## ğŸ§  Part 3: Agent Instruction Design

### The Instruction Hierarchy

Agent instructions should follow ADK-recommended structure:

1. **Role definition** - Who is this agent?
2. **Primary task** - What does it do specifically?
3. **Input specification** - What data to read and from where
4. **Process steps** - How to accomplish the task
5. **Output specification** - What format to produce
6. **Constraints** - Clear boundaries and limitations
7. **Examples** - Show expected input/output
8. **Collaboration** - Which sub-agents to use

---

### Orchestrator vs Worker Instructions

Clear distinction in scope and detail level:

| Aspect | Orchestrator Instructions | Worker Instructions |
|--------|---------------------------|---------------------|
| **Level** | High-level coordination | Detailed processing |
| **Focus** | "Use X agent to do Y" | "How to do Y specifically" |
| **I/O** | File operations explicit | Session state only |
| **Tools** | I/O tools (read/save) | NO tools (pure processor) |
| **Detail** | Workflow steps | Processing algorithms |

**Example - Orchestrator (workflow.py):**
```markdown
**Step 2: Organization**
- Input: Session state has blog_outline and content_split (from Step 1)
- Use `robust_organizer_step` to reorganize draft_ok to match outline
  (reads from session state, writes draft_organized to session state)
- Use `save_step_tool` to save:
  - Step "draft_organized" â†’ draft_organized.md
- Output: draft_organized.md (file)
```

**Example - Worker (organizer.md):**
```markdown
# YOUR TASK

You receive two inputs from session state:
1. **blog_outline** - Approved outline with section headings
2. **content_split** - Dictionary with draft_ok key

## Process Steps
1. Read blog_outline and identify section headings (##)
2. Read content_split["draft_ok"] content chunks
3. Match each chunk to appropriate outline section
4. Arrange content in outline section order
5. Output complete reorganized markdown

# CONSTRAINTS
- Preserve ALL content (no additions, no deletions)
- Use outline structure (section order and headings)
- No file operations (session state only)
```

**Key Difference:** Orchestrator says WHAT to do, worker says HOW to do it.

---

### Input/Output Specification Clarity

Always explicitly state WHERE data comes from and WHERE it goes:

**Good - Worker Instructions:**
```markdown
## Input (from session state)
- `blog_outline`: String containing markdown outline
- `content_split`: Dict with `draft_ok` key

## Output (to session state via output_key)
Reorganized markdown text with all outline headings
```

**Bad - Vague Instructions:**
```markdown
Input: outline and draft content
Output: organized draft
```

**Why this matters:** LLMs need clear data source/destination to avoid hallucinating file operations.

---

### Constraint Language

Use strong, explicit constraint language to prevent scope creep:

**Effective Patterns:**
- "Your ONLY task is..." (narrow scope)
- "Do NOT..." (negative constraints)
- "Preserve ALL content" (completeness)
- "Add NOTHING new" (no generation)
- "Read only from session state" (no file access)

**Example from organizer.md:**
```markdown
# CONSTRAINTS (CRITICAL)
1. **Preserve ALL content**: Every sentence from draft_ok must appear in output
2. **Add NOTHING new**: Do not generate, rephrase, or expand content
3. **Use outline structure**: Section order and headings from blog_outline
4. **No file operations**: Read only from session state, output only text
5. **No content transformation**: Copy-paste only, no rewriting
```

---

### Example-Driven Instruction

Show concrete input/output examples (few-shot learning):

**Pattern:**
```markdown
# EXAMPLE

**Input - blog_outline:**
```markdown
# My Post
## Intro
## Body
```

**Input - content_split.draft_ok:**
```text
I learned React. I built an app.
```

**Output - draft_organized:**
```markdown
# My Post
## Intro
I learned React.
## Body
I built an app.
```
```

**Benefits:**
- Reduces hallucination
- Shows exact expected format
- Clarifies ambiguous instructions
- Provides template for LLM to follow

---

## ğŸ§  Part 4: Agent Configuration Best Practices

### Naming Conventions

Agent variable names MUST match the `name` parameter:

```python
# âœ… Correct - names match
organizer = Agent(name="organizer", ...)

# âŒ Wrong - names don't match
org_agent = Agent(name="organizer", ...)
```

**Why:** Consistency in logs, debugging, and code readability.

---

### Model Selection

Choose appropriate models for task complexity:

```python
# Complex reasoning, content understanding
organizer = Agent(
    model="gemini-3-pro-preview",  # Expensive, powerful
    name="organizer",
    # ...
)

# Simple I/O, data loading
draft_loader = Agent(
    model="gemini-2.5-flash",  # Fast, cheap
    name="draft_loader",
    # ...
)
```

**Guideline:** Use Flash for simple tasks, Pro for complex reasoning.

---

### Description Fields

Every agent needs clear `description` for orchestrator routing:

```python
organizer = Agent(
    name="organizer",
    description="Reorganizes draft content to match outline structure",  # Clear!
    # ...
)

robust_organizer_step = LoopAgent(
    name="robust_organizer_step",
    description="Reorganizes draft with automatic quality validation",  # Explains LoopAgent purpose
    # ...
)
```

**Why:** ADK treats sub-agents as invokable tools; descriptions help LLM choose correct agent.

---

### Sub-Agent Delegation

Workers can delegate to specialist agents for domain knowledge:

```python
organizer = Agent(
    name="organizer",
    instruction=read_instructions("organizer.md"),
    sub_agents=[scribr],  # Delegate content understanding to Scribr
    # ...
)
```

**In instructions (organizer.md):**
```markdown
# COLLABORATION
You may collaborate with Scribr to understand content semantics
and match chunks to sections. Scribr has deep technical understanding.
```

**Pattern:** Worker focuses on structure, delegates semantics to specialists.

---

## ğŸ§  Part 5: Quality Control Integration

### LoopAgent Decision Framework

When to use LoopAgent vs simple Agent:

**Use LoopAgent when:**
- Task complexity is high (requires judgment/reasoning)
- Quality variance is moderate to high (LLM may fail)
- Retry value is high (validation can catch issues)
- Correctness matters more than speed

**Use simple Agent when:**
- Task is mechanical (copy, format, simple transform)
- Quality is predictable (same result every time)
- Errors are acceptable or caught elsewhere
- Speed is critical

**Task 2.2 Decision:** Use LoopAgent
- **Reason:** Content reorganization requires semantic matching, risk of missing sections

---

### Validation Integration

LoopAgent wraps worker + validator:

```python
robust_organizer_step = LoopAgent(
    name="robust_organizer_step",
    description="Reorganizes draft with automatic quality validation",
    sub_agents=[
        organizer,                              # Worker: does the reorganization
        ReorganizationValidationChecker(...),   # Validator: checks quality
    ],
    max_iterations=3,  # Retry up to 3 times
)
```

**Flow:**
1. Worker produces output â†’ session state
2. Validator checks quality
   - âœ… Valid â†’ `escalate=True` â†’ exit loop
   - âŒ Invalid â†’ regular Event â†’ retry worker
3. Repeat until valid OR max_iterations

---

## ğŸ“ Files Created/Modified

**Created:**
- `blogger/instructions/organizer.md` - Worker agent instructions
- `blogger/step_agents/step_2_organize.py` - Agent definitions
- `blogger/validation_utils.py` - Added `check_reorganization_integrity`, `check_heading_order`
- `blogger/validation_checkers.py` - Added `ReorganizationValidationChecker`
- `tests/test_validation_utils.py` - Unit tests for validation functions

**Modified:**
- `blogger/workflow.py` - Updated Step 2 instructions to follow functional architecture

---

## ğŸ¯ Key Takeaways

1. **Three-Layer Architecture:** Orchestrator (I/O) â†’ Workers (logic) â†’ Validators (quality)
2. **Functional Core, Imperative Shell:** Separate side effects from pure processing
3. **Session State:** Shared memory for agent communication, persists throughout session
4. **Load Once, Share:** Load external data at boundaries, share via session state
5. **Instruction Clarity:** Orchestrator says WHAT, workers say HOW
6. **Explicit Constraints:** Use strong language to prevent scope creep
7. **Example-Driven:** Show concrete input/output to guide LLM behavior
8. **Naming Consistency:** Variable names must match `name` parameters
9. **LoopAgent When Needed:** Use for high-complexity, high-variance tasks

---

## ğŸ”— Related Lessons

- **Lesson 2.1:** LoopAgent pattern, BaseAgent validators, session state basics
- **Lesson 1.3:** Workflow orchestration, agent delegation
- **Lesson 1.1:** Agent definitions and instruction patterns

---

## ğŸ“– Official Resources

- [Agent Instructions Best Practices](https://google.github.io/adk-docs/agents/instructions/)
- [Session Management](https://google.github.io/adk-docs/sessions/)
- [Loop Agents](https://google.github.io/adk-docs/agents/workflow-agents/loop-agents/)
