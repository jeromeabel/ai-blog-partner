# Lesson 1.3: Workflow Skeleton & ADK Orchestration

**Task:** Create `blogger/workflow.py` orchestrator agent

**Completed:** Phase 1

---

## ğŸ§  Key Concepts Learned

### ADK Tool Return Convention
All tool functions **must return `dict`**, not strings, None, or primitives.

**Why:** The LLM needs structured data to understand tool results and make decisions.

**Pattern:**
```python
# âœ… Correct
def read_draft_tool(blog_id: str) -> dict:
    return {
        "status": "success",
        "content": draft_text,
        "path": str(draft_path)
    }

# âŒ Wrong
def read_draft_tool(blog_id: str) -> str:
    return draft_text  # LLM can't interpret this well
```

---

### Consistent Tool Signatures
Use `{"status": "success", ...}` pattern for all successful tool returns.

**Benefits:**
- Uniform structure across all tools
- LLM knows operation completed successfully
- Easy to check status in error handling

---

### Path Serialization
When returning `Path` objects in dicts, convert them to strings using `str(path)`.

**Why:** ADK tools must return JSON-serializable data. `Path` objects aren't JSON-serializable.

**Example:**
```python
return {
    "status": "success",
    "path": str(draft_path)  # â† Convert Path to string
}
```

---

### Error Handling via Dicts
Return `{"status": "error", "message": "..."}` for all failures. **Never raise exceptions from tools.**

**Pattern:**
```python
def read_draft_tool(blog_id: str) -> dict:
    try:
        if not draft_path.exists():
            return {
                "status": "error",
                "message": f"Draft not found for '{blog_id}'. Check inputs/{blog_id}/draft.md exists"
            }

        content = draft_path.read_text()
        return {"status": "success", "content": content}

    except Exception as e:
        return {
            "status": "error",
            "message": f"Failed to read draft: {e}"
        }
```

**Why:**
- ADK framework expects dict returns
- Error messages are actionable (help agent self-correct)
- Agent can handle errors gracefully

---

### Generic vs. Specific Keys
Balance between generic key names (e.g., `"content"`) and specific names (e.g., `"draft_content"`).

**Guidelines:**
- Use **generic names** when context is clear (e.g., `read_draft_tool` â†’ `"content"`)
- Use **specific names** when ambiguous (e.g., multiple content types in same dict)

---

### Action-Focused Docstrings
Tool docstrings are **"user manuals" for the LLM**. Describe WHAT the tool does and WHEN to use it, not HOW it's implemented.

**Pattern:**
```python
def read_draft_tool(blog_id: str) -> dict:
    """
    Retrieves the raw draft content for a blog post.

    Use this to load the initial draft markdown file that needs
    to be processed through the blog writing pipeline.

    Args:
        blog_id: Unique identifier for the blog (e.g., "my-ai-journey-2")

    Returns:
        Success: {"status": "success", "content": "...", "path": "..."}
        Error: {"status": "error", "message": "..."}
    """
```

**Avoid:**
- âŒ "This is a placeholder"
- âŒ Implementation details the LLM doesn't need

---

### Error Propagation in Composite Tools
When a tool calls other tools, **check nested tool's `status` and propagate errors immediately**.

**Pattern:**
```python
def composite_tool(blog_id: str) -> dict:
    # Call first tool
    read_result = read_draft_tool(blog_id)
    if read_result["status"] == "error":
        return read_result  # Propagate error immediately

    # Call second tool
    save_result = save_step_tool(blog_id, "output", read_result["content"])
    if save_result["status"] == "error":
        return save_result

    return {"status": "success"}
```

**Wrap everything in try/except** for unexpected errors.

---

### Tools vs. Agents Separation
**Critical principle:** Tools are mechanical, agents are intelligent.

| Tools | Agents |
|-------|--------|
| File I/O | Semantic analysis |
| API calls | Content understanding |
| Calculations | Decision-making |
| Data transformations | Reasoning |

**Guideline:** If a tool would need to "understand" content, that work belongs in an agent instead.

**Example:**
- âŒ `split_draft_tool(draft, outline)` - needs to understand semantic matching
- âœ… `content_splitter` agent - delegates understanding to LLM

---

### Orchestrator Pattern
The orchestrator agent manages workflow via **natural language `instruction` parameter**, not imperative Python code.

**Pattern:**
```python
orchestrator = Agent(
    instruction="""
    Step 1: Draft to Outlines
    - Use draft_loader to load the raw draft
    - Use robust_outline_step to create the outline
    - Use save_step_tool to save the output
    """,
    sub_agents=[draft_loader, robust_outline_step],
    tools=[FunctionTool(save_step_tool)]
)
```

**Key insight:** The instruction **describes what to do**, and the LLM figures out **how to do it**.

---

### Workflow as Natural Language
Agent instructions are prompts, not code. Describe steps with:
- "Use X tool"
- "Collaborate with Y agent"
- "Output Z file"

The orchestrator interprets and executes based on this description.

---

## ğŸ“ Files Created

- `blogger/workflow.py` - Orchestrator agent with 6-step pipeline

---

## ğŸ¯ Takeaway

ADK workflows are **declarative, not imperative**. Tools are mechanical (pure I/O), agents are intelligent (semantic understanding). The orchestrator describes workflow in natural language, and the ADK framework handles execution.
